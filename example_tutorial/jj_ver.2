#include <allegro5/allegro5.h>
#include <allegro5/allegro_primitives.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <math.h>
#include <time.h>
#include <string.h>

/* --- constants --- */
#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

#define BUFFER_W 1280
#define BUFFER_H 720
#define MAP_W 200          /* number of ground samples */
#define TILE_W 4           /* world pixels per ground sample */
#define MAX_BULLETS 100
#define MAX_ENEMIES 20
#define MAX_FLY_ENEMIES 10
#define MAX_ROUNDS 10

/* =========================
   data types
========================= */
typedef struct { bool left, right, jump, change_weapon, esc; } Input;
typedef struct { double x, y; } Camera;
typedef struct { double height[MAP_W]; } Map;

/* bullet: weapon 0 = MG, 1 = Cannon */
typedef struct {
    double x, y, vx, vy;
    bool alive;
    int weapon;
} Bullet;

typedef struct {
    double x, y, vx, vy;
    double cannon_angle;
    bool on_ground;
    int weapon;            /* 0=MG, 1=Cannon */
    bool charging;
    double cannon_power;
    bool mg_firing;
    double mg_fire_time;
    double mg_shot_cooldown;
    bool mg_reloading;
    double mg_reload_time;
} Tank;

/* ground enemy: no shooting; chase player; jump if stuck ~2s */
typedef struct {
    double x, y, vx, vy;
    bool alive;
    bool on_ground;
    int hp;

    double last_x;
    double stuck_time;

    double speed;
    double accel;
    double friction;
} Enemy;

/* flying enemy: burst fire (10 shots in 0.5s) then rest 2s */
typedef struct {
    double x, y, vx;
    double base_y;
    double angle;
    bool alive;

    bool in_burst;
    int  burst_shots_left;
    double shot_interval;
    double shot_timer;
    double rest_timer;
} FlyingEnemy;

/* =========================
   globals (no non-constant initializers)
========================= */
ALLEGRO_DISPLAY* disp;
ALLEGRO_BITMAP* buffer;
Input input;
Camera camera;
Map map_g;
Tank tank;
Bullet bullets[MAX_BULLETS];
Enemy enemies[MAX_ENEMIES];
FlyingEnemy f_enemies[MAX_FLY_ENEMIES];
int round_number = 1;

/* =========================
   display
========================= */
void disp_init(void) {
    disp = al_create_display(BUFFER_W, BUFFER_H);
    if (!disp) exit(1);
    buffer = al_create_bitmap(BUFFER_W, BUFFER_H);
    if (!buffer) exit(1);
}
void disp_pre_draw(void) { al_set_target_bitmap(buffer); }
void disp_post_draw(void) {
    al_set_target_backbuffer(disp);
    al_draw_bitmap(buffer, 0, 0, 0);
    al_flip_display();
}

/* =========================
   map / ground
========================= */
double map_ground_y_from_worldx(double world_x) {
    int x_tile = (int)(world_x / TILE_W);
    if (x_tile < 0) x_tile = 0;
    if (x_tile >= MAP_W) x_tile = MAP_W - 1;
    return map_g.height[x_tile];
}
void map_init(void) {
    double base = BUFFER_H - 220;
    for (int i = 0; i < MAP_W; i++)
        map_g.height[i] = base + (rand() % 20 - 10);
}
void draw_map(void) {
    for (int i = 0; i < MAP_W; i++) {
        double sx = i * TILE_W - camera.x;
        double sy = map_g.height[i] - camera.y;
        al_draw_filled_rectangle(sx, sy, sx + TILE_W, BUFFER_H, al_map_rgb(30, 150, 40));
    }
}

/* =========================
   tank
========================= */
void tank_init(void) {
    tank.x = 50;
    tank.y = map_ground_y_from_worldx(tank.x) - 20;
    tank.vx = 0.0; tank.vy = 0.0;
    tank.on_ground = true;
    tank.cannon_angle = M_PI / 4.0;
    tank.weapon = 0;
    tank.charging = false;
    tank.cannon_power = 0.0;
    tank.mg_firing = false;
    tank.mg_fire_time = 0.0;
    tank.mg_shot_cooldown = 0.0;
    tank.mg_reloading = false;
    tank.mg_reload_time = 0.0;
}
void draw_tank(void) {
    double sx = tank.x - camera.x;
    double sy = tank.y - camera.y;
    al_draw_filled_rectangle(sx, sy, sx + 32, sy + 20, al_map_rgb(60, 120, 180));
    double cx = sx + 16, cy = sy + 10;
    double bx = cx + cos(tank.cannon_angle) * 18;
    double by = cy + sin(tank.cannon_angle) * 18;
    al_draw_line(cx, cy, bx, by, al_map_rgb(200, 200, 0), 4);

    /* cannon gauge */
    if (tank.charging && tank.weapon == 1) {
        double gw = tank.cannon_power * 10;
        if (gw > 150) gw = 150;
        al_draw_filled_rectangle(sx, sy - 20, sx + gw, sy - 10, al_map_rgb(255, 0, 0));
        al_draw_rectangle(sx, sy - 20, sx + 150, sy - 10, al_map_rgb(255, 255, 255), 2);
    }
    /* MG reload gauge */
    if (tank.mg_reloading) {
        double total = 2.0;
        double filled = (total - tank.mg_reload_time) / total;
        if (filled < 0) filled = 0; if (filled > 1) filled = 1;
        double gw = 150 * filled;
        al_draw_rectangle(sx, sy - 35, sx + 150, sy - 20, al_map_rgb(255, 255, 255), 2);
        al_draw_filled_rectangle(sx + 1, sy - 34, sx + 1 + gw, sy - 21, al_map_rgb(0, 200, 255));
    }
}
void tank_update(double dt) {
    const double accel = 0.4, maxspeed = 3.0, friction = 0.85, gravity = 0.5;
    if (input.left)  tank.vx -= accel;
    if (input.right) tank.vx += accel;
    tank.vx *= friction;
    if (tank.vx > maxspeed) tank.vx = maxspeed;
    if (tank.vx < -maxspeed) tank.vx = -maxspeed;
    tank.x += tank.vx;

    if (input.jump && tank.on_ground) { tank.vy = -8; tank.on_ground = false; }
    tank.vy += gravity; tank.y += tank.vy;
    double ground = map_ground_y_from_worldx(tank.x);
    if (tank.y > ground - 20) { tank.y = ground - 20; tank.vy = 0; tank.on_ground = true; }

    if (input.change_weapon) { tank.weapon = 1 - tank.weapon; input.change_weapon = false; }

    if (tank.weapon == 1 && tank.charging) {
        tank.cannon_power += 0.2;
        if (tank.cannon_power > 15) tank.cannon_power = 15;
    }

    /* MG burst with reload (player) */
    if (tank.weapon == 0) {
        if (tank.mg_shot_cooldown > 0) tank.mg_shot_cooldown -= dt;
        if (tank.mg_reloading) {
            tank.mg_reload_time -= dt;
            if (tank.mg_reload_time <= 0) {
                tank.mg_reloading = false;
                tank.mg_fire_time = 0;
                tank.mg_shot_cooldown = 0;
            }
        }
        else {
            if (tank.mg_firing) {
                tank.mg_fire_time += dt;
                if (tank.mg_shot_cooldown <= 0) {
                    for (int i = 0; i < MAX_BULLETS; i++) {
                        if (!bullets[i].alive) {
                            bullets[i].alive = true;
                            bullets[i].x = tank.x + 16;
                            bullets[i].y = tank.y + 10;
                            bullets[i].weapon = 0;
                            bullets[i].vx = cos(tank.cannon_angle) * 12.0; /* 8*1.5 */
                            bullets[i].vy = sin(tank.cannon_angle) * 12.0;
                            tank.mg_shot_cooldown = 0.1;
                            break;
                        }
                    }
                }
                if (tank.mg_fire_time >= 3.0) {
                    tank.mg_reloading = true;
                    tank.mg_reload_time = 2.0;
                    tank.mg_firing = false;
                }
            }
            else {
                tank.mg_fire_time = 0;
            }
        }
    }

    /* camera */
    camera.x = tank.x - BUFFER_W / 3.0;
    camera.y = tank.y - BUFFER_H / 1.5;
}

/* =========================
   cannon trajectory preview
   - shown while tank.weapon==1 and tank.charging == true
   - white color, 50% transparent
========================= */
void draw_cannon_trajectory(void) {
    if (!(tank.weapon == 1 && tank.charging)) return;

    double v0 = tank.cannon_power * 1.4;   /* same scale as fire */
    if (v0 < 0.5) return;

    double x = tank.x + 16.0;
    double y = tank.y + 10.0;
    double vx = cos(tank.cannon_angle) * v0;
    double vy = sin(tank.cannon_angle) * v0;

    double prev_sx = -1.0, prev_sy = -1.0;

    /* 흰색, 알파 128 (50%) */
    ALLEGRO_COLOR col_line = al_map_rgba(255, 255, 255, 50);
    ALLEGRO_COLOR col_dot = al_map_rgba(255, 255, 255, 50);

    for (int step = 0; step < 300; ++step) {
        x += vx;
        y += vy;
        vy += 0.3; /* gravity */

        if (x < 0 || x > MAP_W * TILE_W || y > BUFFER_H + 200) break;
        double gy = map_ground_y_from_worldx(x);
        if (y >= gy - 2.0) break;

        double sx = x - camera.x;
        double sy = y - camera.y;

        if (prev_sx >= 0.0) {
            al_draw_line(prev_sx, prev_sy, sx, sy, col_line, 2.0f);
        }
        if (step % 3 == 0) {
            al_draw_filled_circle(sx, sy, 2.0, col_dot);
        }
        prev_sx = sx; prev_sy = sy;
    }
}



/* =========================
   bullets
========================= */
void bullets_update(void) {
    for (int i = 0; i < MAX_BULLETS; i++) {
        if (!bullets[i].alive) continue;
        if (bullets[i].weapon == 1) bullets[i].vy += 0.3; /* gravity for cannon */
        bullets[i].x += bullets[i].vx;
        bullets[i].y += bullets[i].vy;
        if (bullets[i].x < 0 || bullets[i].x > MAP_W * TILE_W || bullets[i].y > BUFFER_H)
            bullets[i].alive = false;
    }
}
void draw_bullets(void) {
    for (int i = 0; i < MAX_BULLETS; i++) {
        if (!bullets[i].alive) continue;
        double sx = bullets[i].x - camera.x;
        double sy = bullets[i].y - camera.y;
        ALLEGRO_COLOR col = (bullets[i].weapon == 0) ? al_map_rgb(255, 255, 0) : al_map_rgb(255, 128, 0);
        al_draw_filled_circle(sx, sy, 4, col);
    }
}

/* =========================
   ground enemies: chase + jump if stuck
========================= */
void spawn_enemies(void) {
    int count = round_number + 2;
    for (int i = 0; i < MAX_ENEMIES && count > 0; i++) {
        if (!enemies[i].alive) {
            enemies[i].alive = true;

            if (rand() % 2) enemies[i].x = -50 + rand() % 30;
            else enemies[i].x = MAP_W * TILE_W + (rand() % 30);

            enemies[i].y = map_ground_y_from_worldx(enemies[i].x) - 20;
            enemies[i].vx = 0.0;
            enemies[i].vy = 0.0;
            enemies[i].on_ground = true;
            enemies[i].hp = 10 + round_number * 5;

            enemies[i].last_x = enemies[i].x;
            enemies[i].stuck_time = 0.0;

            enemies[i].speed = 1.2 + round_number * 0.15;
            enemies[i].accel = 0.15;
            enemies[i].friction = 0.90;

            count--;
        }
    }
}
void enemies_update(double dt) {
    const double gravity = 0.5;
    const double jump_power = -8.5;
    const double stuck_threshold = 1.0;
    const double stuck_jump_time = 2.0;

    for (int i = 0; i < MAX_ENEMIES; i++) {
        Enemy* e = &enemies[i];
        if (!e->alive) continue;

        /* move towards tank (no shooting) */
        double dir = (tank.x > e->x) ? 1.0 : -1.0;
        double target_vx = dir * e->speed;

        double dv = target_vx - e->vx;
        if (dv > e->accel) dv = e->accel;
        if (dv < -e->accel) dv = -e->accel;
        e->vx += dv;
        e->vx *= e->friction;

        e->vy += gravity;

        e->x += e->vx;
        e->y += e->vy;

        double ground = map_ground_y_from_worldx(e->x);
        if (e->y > ground - 20) {
            e->y = ground - 20;
            e->vy = 0.0;
            e->on_ground = true;
        }
        else {
            e->on_ground = false;
        }

        if (e->x < 0) { e->x = 0; e->vx = fabs(e->vx); }
        if (e->x > MAP_W * TILE_W) { e->x = MAP_W * TILE_W; e->vx = -fabs(e->vx); }

        /* stuck detection */
        if (fabs(e->x - e->last_x) <= stuck_threshold) {
            e->stuck_time += dt;
        }
        else {
            e->stuck_time = 0.0;
            e->last_x = e->x;
        }

        if (e->stuck_time >= stuck_jump_time && e->on_ground) {
            e->vy = jump_power;
            e->vx += dir * 1.5; /* small horizontal boost */
            e->stuck_time = 0.0;
        }
    }
}
void enemies_draw(void) {
    for (int i = 0; i < MAX_ENEMIES; i++) {
        Enemy* e = &enemies[i];
        if (!e->alive) continue;
        double sx = e->x - camera.x, sy = e->y - camera.y;
        al_draw_filled_rectangle(sx, sy, sx + 32, sy + 20, al_map_rgb(200, 50, 50));
    }
}

/* =========================
   flying enemies: burst fire
========================= */
void flying_enemies_init(void) {
    for (int i = 0; i < MAX_FLY_ENEMIES; i++) {
        f_enemies[i].alive = false;
        f_enemies[i].in_burst = false;
        f_enemies[i].burst_shots_left = 0;
        f_enemies[i].shot_interval = 0.05;
        f_enemies[i].shot_timer = 0.0;
        f_enemies[i].rest_timer = 2.0;
    }
}
void spawn_flying_enemy(void) {
    for (int i = 0; i < MAX_FLY_ENEMIES; i++) {
        if (!f_enemies[i].alive) {
            f_enemies[i].alive = true;
            f_enemies[i].x = rand() % (MAP_W * TILE_W);
            f_enemies[i].base_y = 100 + rand() % 100;
            f_enemies[i].y = f_enemies[i].base_y;
            f_enemies[i].vx = (rand() % 2 ? 1.0 : -1.0) * (1.0 + round_number * 0.2);
            f_enemies[i].angle = 0.0;

            f_enemies[i].in_burst = false;
            f_enemies[i].burst_shots_left = 0;
            f_enemies[i].shot_interval = 0.05;
            f_enemies[i].shot_timer = 0.0;
            f_enemies[i].rest_timer = 0.5 + (rand() % 50) / 100.0;

            break;
        }
    }
}
void flying_enemies_update(double dt) {
    for (int i = 0; i < MAX_FLY_ENEMIES; i++) {
        FlyingEnemy* fe = &f_enemies[i];
        if (!fe->alive) continue;

        /* movement: sine on Y, bounce on edges in X */
        fe->angle += dt * 2.0;
        fe->y = fe->base_y + sin(fe->angle) * 30.0;
        fe->x += fe->vx;

        if (fe->x < 0) { fe->x = 0; fe->vx *= -1; }
        if (fe->x > MAP_W * TILE_W) { fe->x = MAP_W * TILE_W; fe->vx *= -1; }

        /* burst logic */
        if (fe->in_burst) {
            fe->shot_timer -= dt;

            while (fe->shot_timer <= 0.0 && fe->burst_shots_left > 0) {
                for (int j = 0; j < MAX_BULLETS; j++) {
                    if (!bullets[j].alive) {
                        bullets[j].alive = true;
                        bullets[j].x = fe->x;
                        bullets[j].y = fe->y;
                        bullets[j].weapon = 0; /* MG round */

                        double dx = tank.x - fe->x;
                        double dy = tank.y - fe->y;
                        double ang = atan2(dy, dx);

                        bullets[j].vx = cos(ang) * 8.0;
                        bullets[j].vy = sin(ang) * 8.0;
                        break;
                    }
                }

                fe->burst_shots_left--;
                fe->shot_timer += fe->shot_interval;

                if (fe->burst_shots_left <= 0) {
                    fe->in_burst = false;
                    fe->rest_timer = 2.0;
                }
            }
        }
        else {
            fe->rest_timer -= dt;
            if (fe->rest_timer <= 0.0) {
                fe->in_burst = true;
                fe->burst_shots_left = 10;
                fe->shot_timer = 0.0; /* shoot immediately */
            }
        }
    }
}
void flying_enemies_draw(void) {
    for (int i = 0; i < MAX_FLY_ENEMIES; i++) {
        FlyingEnemy* fe = &f_enemies[i];
        if (!fe->alive) continue;
        double sx = fe->x - camera.x, sy = fe->y - camera.y;
        al_draw_filled_rectangle(sx, sy, sx + 28, sy + 16, al_map_rgb(180, 0, 180));
    }
}

/* =========================
   round / utils
========================= */
static bool any_ground_enemies_alive(void) {
    for (int i = 0; i < MAX_ENEMIES; ++i)
        if (enemies[i].alive) return true;
    return false;
}
static bool any_flying_enemies_alive(void) {
    for (int i = 0; i < MAX_FLY_ENEMIES; ++i)
        if (f_enemies[i].alive) return true;
    return false;
}
void next_round_if_cleared(void) {
    if (!any_ground_enemies_alive() && !any_flying_enemies_alive()) {
        round_number++;
        if (round_number > MAX_ROUNDS) round_number = MAX_ROUNDS;
        spawn_enemies();
        spawn_flying_enemy();
        if (round_number % 2 == 0) spawn_flying_enemy();
    }
}

/* =========================
   main
========================= */
int main(void) {
    memset(&input, 0, sizeof(input));
    camera.x = 0.0; camera.y = 0.0;

    srand((unsigned int)time(NULL));
    if (!al_init()) return 1;
    al_install_keyboard(); al_install_mouse(); al_init_primitives_addon();
    disp_init();

    ALLEGRO_TIMER* timer = al_create_timer(1.0 / 60.0);
    ALLEGRO_EVENT_QUEUE* queue = al_create_event_queue();
    al_register_event_source(queue, al_get_keyboard_event_source());
    al_register_event_source(queue, al_get_mouse_event_source());
    al_register_event_source(queue, al_get_display_event_source(disp));
    al_register_event_source(queue, al_get_timer_event_source(timer));

    map_init(); tank_init();
    flying_enemies_init();
    spawn_enemies();
    spawn_flying_enemy();

    al_start_timer(timer);
    bool done = false; ALLEGRO_EVENT event;

    while (!done) {
        al_wait_for_event(queue, &event);
        switch (event.type) {
        case ALLEGRO_EVENT_DISPLAY_CLOSE: done = true; break;
        case ALLEGRO_EVENT_TIMER: {
            double dt = 1.0 / 60.0;
            tank_update(dt);
            bullets_update();
            enemies_update(dt);
            flying_enemies_update(dt);
            next_round_if_cleared();
            break;
        }
        case ALLEGRO_EVENT_KEY_DOWN:
            if (event.keyboard.keycode == ALLEGRO_KEY_A) input.left = true;
            if (event.keyboard.keycode == ALLEGRO_KEY_D) input.right = true;
            if (event.keyboard.keycode == ALLEGRO_KEY_W) input.jump = true;
            if (event.keyboard.keycode == ALLEGRO_KEY_R) input.change_weapon = true;
            break;
        case ALLEGRO_EVENT_KEY_UP:
            if (event.keyboard.keycode == ALLEGRO_KEY_A) input.left = false;
            if (event.keyboard.keycode == ALLEGRO_KEY_D) input.right = false;
            if (event.keyboard.keycode == ALLEGRO_KEY_W) input.jump = false;
            break;
        case ALLEGRO_EVENT_MOUSE_AXES: {
            double cx = tank.x - camera.x + 16, cy = tank.y - camera.y + 10;
            double dx = event.mouse.x - cx, dy = event.mouse.y - cy;
            tank.cannon_angle = atan2(dy, dx);
            break;
        }
        case ALLEGRO_EVENT_MOUSE_BUTTON_DOWN:
            if (event.mouse.button == 1) {
                if (tank.weapon == 1) { tank.charging = true; tank.cannon_power = 0; }
                else if (!tank.mg_reloading) tank.mg_firing = true;
            }
            break;
        case ALLEGRO_EVENT_MOUSE_BUTTON_UP:
            if (event.mouse.button == 1) {
                if (tank.weapon == 1 && tank.charging) {
                    for (int i = 0; i < MAX_BULLETS; i++) {
                        if (!bullets[i].alive) {
                            bullets[i].alive = true;
                            bullets[i].x = tank.x + 16;
                            bullets[i].y = tank.y + 10;
                            bullets[i].weapon = 1;
                            bullets[i].vx = cos(tank.cannon_angle) * tank.cannon_power * 1.4;
                            bullets[i].vy = sin(tank.cannon_angle) * tank.cannon_power * 1.4;
                            break;
                        }
                    }
                    tank.charging = false; tank.cannon_power = 0;
                }
                else if (tank.weapon == 0) {
                    tank.mg_firing = false; tank.mg_fire_time = 0;
                }
            }
            break;
        }

        disp_pre_draw();
        al_clear_to_color(al_map_rgb(20, 20, 30));
        draw_map();
        /* draw trajectory preview above the map so it is visible */
        draw_cannon_trajectory();
        draw_tank();
        draw_bullets();
        enemies_draw();
        flying_enemies_draw();
        disp_post_draw();
    }

    al_destroy_bitmap(buffer);
    al_destroy_display(disp);
    al_destroy_timer(timer);
    al_destroy_event_queue(queue);
    return 0;
}
