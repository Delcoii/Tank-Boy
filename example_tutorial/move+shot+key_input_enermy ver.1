#include <allegro5/allegro5.h>
#include <allegro5/allegro_primitives.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <math.h>
#include <time.h>

/* --- 상수 정의 --- */
#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

#define BUFFER_W 1280
#define BUFFER_H 720
#define MAP_W 200
#define MAX_BULLETS 100
#define MAX_ENEMIES 20
#define MAX_FLY_ENEMIES 10
#define MAX_ROUNDS 10

/* =========================
    구조체 정의
========================= */
typedef struct { bool left, right, jump, change_weapon, esc; } Input;
typedef struct { double x, y; } Camera;
typedef struct { double height[MAP_W]; } Map;

typedef struct {
    double x, y, vx, vy;
    bool alive;
    int weapon; // 0=MG,1=Cannon
} Bullet;

typedef struct {
    double x, y, vx, vy;
    double cannon_angle;
    bool on_ground;
    int weapon;
    bool charging;
    double cannon_power;
    bool mg_firing;
    double mg_fire_time;
    double mg_shot_cooldown;
    bool mg_reloading;
    double mg_reload_time;
} Tank;

typedef struct {
    double x, y, vx, vy;
    double cannon_angle;
    int weapon;
    bool alive;
    double fire_cooldown;
    int hp;
} Enemy;

typedef struct {
    double x, y, vx;
    double base_y;
    double angle;
    bool alive;
    double fire_timer;
} FlyingEnemy;

/* =========================
    전역 변수
========================= */
ALLEGRO_DISPLAY* disp;
ALLEGRO_BITMAP* buffer;
Input input = { 0 };
Camera camera = { 0 };
Map map;
Tank tank;
Bullet bullets[MAX_BULLETS];
Enemy enemies[MAX_ENEMIES];
FlyingEnemy f_enemies[MAX_FLY_ENEMIES];
int round_number = 1;

/* =========================
    디스플레이 초기화
========================= */
void disp_init() {
    disp = al_create_display(BUFFER_W, BUFFER_H);
    if (!disp) exit(1);
    buffer = al_create_bitmap(BUFFER_W, BUFFER_H);
    if (!buffer) exit(1);
}
void disp_pre_draw() { al_set_target_bitmap(buffer); }
void disp_post_draw() {
    al_set_target_backbuffer(disp);
    al_draw_bitmap(buffer, 0, 0, 0);
    al_flip_display();
}

/* =========================
    맵 관련
========================= */
void map_init() {
    double base = BUFFER_H - 220;
    for (int i = 0; i < MAP_W; i++)
        map.height[i] = base + (rand() % 20 - 10);
}
double map_ground_y(int x_tile) {
    if (x_tile < 0) x_tile = 0;
    if (x_tile >= MAP_W) x_tile = MAP_W - 1;
    return map.height[x_tile];
}
void draw_map() {
    for (int i = 0; i < MAP_W; i++) {
        double sx = i * 4 - camera.x;
        double sy = map.height[i] - camera.y;
        al_draw_filled_rectangle(sx, sy, sx + 4, BUFFER_H, al_map_rgb(30, 150, 40));
    }
}

/* =========================
    탱크 관련
========================= */
void tank_init() {
    tank.x = 50;
    tank.y = map_ground_y((int)tank.x) - 20;
    tank.vx = tank.vy = 0;
    tank.on_ground = true;
    tank.cannon_angle = M_PI / 4;
    tank.weapon = 0;
    tank.charging = false;
    tank.cannon_power = 0;
    tank.mg_firing = false;
    tank.mg_fire_time = 0;
    tank.mg_shot_cooldown = 0;
    tank.mg_reloading = false;
    tank.mg_reload_time = 0;
}

void draw_tank() {
    double sx = tank.x - camera.x;
    double sy = tank.y - camera.y;
    al_draw_filled_rectangle(sx, sy, sx + 32, sy + 20, al_map_rgb(60, 120, 180));
    double cx = sx + 16, cy = sy + 10;
    double bx = cx + cos(tank.cannon_angle) * 18;
    double by = cy + sin(tank.cannon_angle) * 18;
    al_draw_line(cx, cy, bx, by, al_map_rgb(200, 200, 0), 4);

    // 캐논 게이지
    if (tank.charging && tank.weapon == 1) {
        double gw = tank.cannon_power * 10;
        al_draw_filled_rectangle(sx, sy - 20, sx + gw, sy - 10, al_map_rgb(255, 0, 0));
        al_draw_rectangle(sx, sy - 20, sx + 150, sy - 10, al_map_rgb(255, 255, 255), 2);
    }
    // 기관총 재장전 게이지
    if (tank.mg_reloading) {
        double total = 2.0;
        double filled = (total - tank.mg_reload_time) / total;
        if (filled < 0) filled = 0; if (filled > 1) filled = 1;
        double gw = 150 * filled;
        al_draw_rectangle(sx, sy - 35, sx + 150, sy - 20, al_map_rgb(255, 255, 255), 2);
        al_draw_filled_rectangle(sx + 1, sy - 34, sx + 1 + gw, sy - 21, al_map_rgb(0, 200, 255));
    }
}

void tank_update(double dt) {
    const double accel = 0.4, maxspeed = 3.0, friction = 0.85, gravity = 0.5;
    if (input.left) tank.vx -= accel;
    if (input.right) tank.vx += accel;
    tank.vx *= friction;
    if (tank.vx > maxspeed) tank.vx = maxspeed;
    if (tank.vx < -maxspeed) tank.vx = -maxspeed;
    tank.x += tank.vx;

    if (input.jump && tank.on_ground) { tank.vy = -8; tank.on_ground = false; }
    tank.vy += gravity; tank.y += tank.vy;
    double ground = map_ground_y((int)tank.x);
    if (tank.y > ground - 20) { tank.y = ground - 20; tank.vy = 0; tank.on_ground = true; }

    if (input.change_weapon) { tank.weapon = 1 - tank.weapon; input.change_weapon = false; }

    if (tank.weapon == 1 && tank.charging) {
        tank.cannon_power += 0.2;
        if (tank.cannon_power > 15) tank.cannon_power = 15;
    }

    // 기관총 연사/재장전
    if (tank.weapon == 0) {
        if (tank.mg_shot_cooldown > 0) tank.mg_shot_cooldown -= dt;
        if (tank.mg_reloading) {
            tank.mg_reload_time -= dt;
            if (tank.mg_reload_time <= 0) {
                tank.mg_reloading = false;
                tank.mg_fire_time = 0;
                tank.mg_shot_cooldown = 0;
            }
        }
        else {
            if (tank.mg_firing) {
                tank.mg_fire_time += dt;
                if (tank.mg_shot_cooldown <= 0) {
                    for (int i = 0; i < MAX_BULLETS; i++) {
                        if (!bullets[i].alive) {
                            bullets[i].alive = true;
                            bullets[i].x = tank.x + 16;
                            bullets[i].y = tank.y + 10;
                            bullets[i].weapon = 0;
                            bullets[i].vx = cos(tank.cannon_angle) * 8.0 * 1.5;
                            bullets[i].vy = sin(tank.cannon_angle) * 8.0 * 1.5;
                            tank.mg_shot_cooldown = 0.1;
                            break;
                        }
                    }
                }
                if (tank.mg_fire_time >= 3.0) {
                    tank.mg_reloading = true;
                    tank.mg_reload_time = 2.0;
                    tank.mg_firing = false;
                }
            }
            else tank.mg_fire_time = 0;
        }
    }

    camera.x = tank.x - BUFFER_W / 3;
    camera.y = tank.y - BUFFER_H / 1.5;
}

/* =========================
    탄환 관련
========================= */
void bullets_update() {
    for (int i = 0; i < MAX_BULLETS; i++) {
        if (!bullets[i].alive) continue;
        if (bullets[i].weapon == 1) bullets[i].vy += 0.3; // 중력
        bullets[i].x += bullets[i].vx;
        bullets[i].y += bullets[i].vy;
        if (bullets[i].x < 0 || bullets[i].x > MAP_W * 4 || bullets[i].y > BUFFER_H) bullets[i].alive = false;
    }
}
void draw_bullets() {
    for (int i = 0; i < MAX_BULLETS; i++) {
        if (!bullets[i].alive) continue;
        double sx = bullets[i].x - camera.x;
        double sy = bullets[i].y - camera.y;
        ALLEGRO_COLOR col = (bullets[i].weapon == 0) ? al_map_rgb(255, 255, 0) : al_map_rgb(255, 128, 0);
        al_draw_filled_circle(sx, sy, 3, col);
    }
}

/* =========================
    땅 적 관련
========================= */
void spawn_enemies() {
    int count = round_number + 2;
    for (int i = 0; i < MAX_ENEMIES && count>0; i++) {
        if (!enemies[i].alive) {
            enemies[i].alive = true;
            if (rand() % 2) enemies[i].x = -50 + rand() % 30;
            else enemies[i].x = BUFFER_W + rand() % 30;
            enemies[i].y = map_ground_y((int)(enemies[i].x / 4)) - 20;
            enemies[i].vx = (rand() % 2 ? 1 : -1) * (1.0 + round_number * 0.2);
            enemies[i].cannon_angle = M_PI / 4;
            enemies[i].weapon = rand() % 2;
            enemies[i].fire_cooldown = rand() % 60 / 60.0;
            enemies[i].hp = 10 + round_number * 5;
            count--;
        }
    }
}
void enemies_update(double dt) {
    for (int i = 0; i < MAX_ENEMIES; i++) {
        Enemy* e = &enemies[i];
        if (!e->alive) continue;
        e->x += e->vx;
        double ground = map_ground_y((int)(e->x / 4));
        if (e->y > ground - 20) { e->y = ground - 20; e->vy = 0; }

        // 화면 끝에서 튕기기
        if (e->x < 0) { e->x = 0; e->vx *= -1; }
        if (e->x > MAP_W * 4) { e->x = MAP_W * 4; e->vx *= -1; }

        double dx = tank.x - e->x, dy = tank.y - e->y;
        e->cannon_angle = atan2(dy, dx);
        e->fire_cooldown -= dt;
        if (e->fire_cooldown <= 0) {
            for (int j = 0; j < MAX_BULLETS; j++) {
                if (!bullets[j].alive) {
                    bullets[j].alive = true;
                    bullets[j].x = e->x + 16;
                    bullets[j].y = e->y + 10;
                    bullets[j].weapon = e->weapon;
                    bullets[j].vx = cos(e->cannon_angle) * 6.0;
                    bullets[j].vy = sin(e->cannon_angle) * 6.0;
                    e->fire_cooldown = 1.0 + rand() % 60 / 30.0;
                    break;
                }
            }
        }
    }
}
void enemies_draw() {
    for (int i = 0; i < MAX_ENEMIES; i++) {
        Enemy* e = &enemies[i];
        if (!e->alive) continue;
        double sx = e->x - camera.x, sy = e->y - camera.y;
        al_draw_filled_rectangle(sx, sy, sx + 32, sy + 20, al_map_rgb(200, 50, 50));
        al_draw_line(sx + 16, sy + 10, sx + 16 + cos(e->cannon_angle) * 18, sy + 10 + sin(e->cannon_angle) * 18, al_map_rgb(255, 255, 0), 4);
    }
}

/* =========================
    공중 적 관련
========================= */
void flying_enemies_init() {
    for (int i = 0; i < MAX_FLY_ENEMIES; i++) f_enemies[i].alive = false;
}
void spawn_flying_enemy() {
    for (int i = 0; i < MAX_FLY_ENEMIES; i++) {
        if (!f_enemies[i].alive) {
            f_enemies[i].alive = true;
            f_enemies[i].x = rand() % BUFFER_W;
            f_enemies[i].base_y = 100 + rand() % 100;
            f_enemies[i].y = f_enemies[i].base_y;
            f_enemies[i].vx = (rand() % 2 ? 1 : -1) * (1.0 + round_number * 0.2);
            f_enemies[i].angle = 0;
            f_enemies[i].fire_timer = 0;
            break;
        }
    }
}
void flying_enemies_update(double dt) {
    for (int i = 0; i < MAX_FLY_ENEMIES; i++) {
        FlyingEnemy* fe = &f_enemies[i];
        if (!fe->alive) continue;
        fe->angle += dt * 2.0;
        fe->y = fe->base_y + sin(fe->angle) * 30;
        fe->x += fe->vx;
        if (fe->x < 0) { fe->x = 0; fe->vx *= -1; }
        if (fe->x > MAP_W * 4) { fe->x = MAP_W * 4; fe->vx *= -1; }

        fe->fire_timer -= dt;
        if (fe->fire_timer <= 0) {
            for (int j = 0; j < MAX_BULLETS; j++) {
                if (!bullets[j].alive) {
                    bullets[j].alive = true;
                    bullets[j].x = fe->x;
                    bullets[j].y = fe->y;
                    bullets[j].weapon = 0;
                    double dx = tank.x - fe->x, dy = tank.y - fe->y;
                    double angle = atan2(dy, dx);
                    bullets[j].vx = cos(angle) * 8;
                    bullets[j].vy = sin(angle) * 8;
                    break;
                }
            }
            if (fe->fire_timer <= -0.5) fe->fire_timer = 2.0;
            else fe->fire_timer = -0.5;
        }
    }
}
void flying_enemies_draw() {
    for (int i = 0; i < MAX_FLY_ENEMIES; i++) {
        FlyingEnemy* fe = &f_enemies[i];
        if (!fe->alive) continue;
        double sx = fe->x - camera.x, sy = fe->y - camera.y;
        al_draw_filled_rectangle(sx, sy, sx + 28, sy + 16, al_map_rgb(180, 0, 180));
    }
}

/* =========================
    메인
========================= */
int main() {
    srand((unsigned int)time(NULL));
    if (!al_init()) return 1;
    al_install_keyboard(); al_install_mouse(); al_init_primitives_addon();
    disp_init();

    ALLEGRO_TIMER* timer = al_create_timer(1.0 / 60);
    ALLEGRO_EVENT_QUEUE* queue = al_create_event_queue();
    al_register_event_source(queue, al_get_keyboard_event_source());
    al_register_event_source(queue, al_get_mouse_event_source());
    al_register_event_source(queue, al_get_display_event_source(disp));
    al_register_event_source(queue, al_get_timer_event_source(timer));

    map_init(); tank_init();
    for (int i = 0; i < MAX_BULLETS; i++) bullets[i].alive = false;
    for (int i = 0; i < MAX_ENEMIES; i++) enemies[i].alive = false;
    flying_enemies_init();

    spawn_enemies();
    spawn_flying_enemy();

    al_start_timer(timer);
    bool done = false; ALLEGRO_EVENT event;

    while (!done) {
        al_wait_for_event(queue, &event);
        switch (event.type) {
        case ALLEGRO_EVENT_DISPLAY_CLOSE: done = true; break;
        case ALLEGRO_EVENT_TIMER:
            tank_update(1.0 / 60);
            bullets_update();
            enemies_update(1.0 / 60);
            flying_enemies_update(1.0 / 60);
            break;
        case ALLEGRO_EVENT_KEY_DOWN:
            if (event.keyboard.keycode == ALLEGRO_KEY_A) input.left = true;
            if (event.keyboard.keycode == ALLEGRO_KEY_D) input.right = true;
            if (event.keyboard.keycode == ALLEGRO_KEY_W) input.jump = true;
            if (event.keyboard.keycode == ALLEGRO_KEY_R) input.change_weapon = true;
            break;
        case ALLEGRO_EVENT_KEY_UP:
            if (event.keyboard.keycode == ALLEGRO_KEY_A) input.left = false;
            if (event.keyboard.keycode == ALLEGRO_KEY_D) input.right = false;
            if (event.keyboard.keycode == ALLEGRO_KEY_W) input.jump = false;
            break;
        case ALLEGRO_EVENT_MOUSE_AXES: {
            double cx = tank.x - camera.x + 16, cy = tank.y - camera.y + 10;
            double dx = event.mouse.x - cx, dy = event.mouse.y - cy;
            tank.cannon_angle = atan2(dy, dx);
            break;
        }
        case ALLEGRO_EVENT_MOUSE_BUTTON_DOWN:
            if (event.mouse.button == 1) {
                if (tank.weapon == 1) { tank.charging = true; tank.cannon_power = 0; }
                else if (!tank.mg_reloading) tank.mg_firing = true;
            }
            break;
        case ALLEGRO_EVENT_MOUSE_BUTTON_UP:
            if (event.mouse.button == 1) {
                if (tank.weapon == 1 && tank.charging) {
                    for (int i = 0; i < MAX_BULLETS; i++) {
                        if (!bullets[i].alive) {
                            bullets[i].alive = true;
                            bullets[i].x = tank.x + 16;
                            bullets[i].y = tank.y + 10;
                            bullets[i].weapon = 1;
                            bullets[i].vx = cos(tank.cannon_angle) * tank.cannon_power * 1.4; // 2배 거리
                            bullets[i].vy = sin(tank.cannon_angle) * tank.cannon_power * 1.4;
                            break;
                        }
                    }
                    tank.charging = false; tank.cannon_power = 0;
                }
                else if (tank.weapon == 0) {
                    tank.mg_firing = false; tank.mg_fire_time = 0;
                }
            }
            break;
        }

        disp_pre_draw();
        al_clear_to_color(al_map_rgb(20, 20, 30));
        draw_map(); draw_tank(); draw_bullets();
        enemies_draw(); flying_enemies_draw();
        disp_post_draw();
    }

    al_destroy_bitmap(buffer);
    al_destroy_display(disp);
    al_destroy_timer(timer);
    al_destroy_event_queue(queue);
    return 0;
}
